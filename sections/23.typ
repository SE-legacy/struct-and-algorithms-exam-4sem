/ Алгоритмы «разделяй и властвуй»: --- это класс алгоритмов, которые решают задачу, разбивая её на несколько подзадач того же типа, решают их рекурсивно, а затем объединяют результаты.

== Быстрая сортировка

*Принцип работы:*
1. Выбирается опорный элемент (`pivot`) из массива.
2. Массив перестраивается (`partition`) так, что элементы меньше опорного оказываются слева, а больше или равные --- справа.
3. Рекурсивно сортируются подмассивы слева и справа от опорного.
4. Рекурсия завершается, когда подмассивы пусты или содержат один элемент.

*Особенности:*

- Не требует дополнительной памяти
- Выбор опорного элемента влияет на производительность.
- В среднем работает за $O(n log n)$.
- В худшем случае (например, отсортированный массив и плохой выбор опорного) --- $O(n^2)$.

*Реализация на C++:*
```cpp
int partition(std::vector<int>& arr, int low, int high) {
  int pivot = arr[high];
  int i = low - 1;
  for (int j = low; j < high; ++j) {
    if (arr[j] <= pivot) {
      ++i;
      std::swap(arr[i], arr[j]);
    }Принцип работы
  }
  std::swap(arr[i+1], arr[high]);
  return i + 1;
}

void quick_sort(std::vector<int>& arr, int low, int high) {
  if (low < high) {
    int pi = partition(arr, low, high);
    quick_sort(arr, low, pi - 1);
    quick_sort(arr, pi + 1, high);
  }
}
```

*Оценка сложности.* Найдём функцию трудоёмкости как у алгоритма «разделяй и властвуй». При удачном выборе опорного элемента (`pivot`), массив на каждом шаге делится примерно пополам.  Количество уровней рекурсии примерно равно $log n$. На каждом уровне выполняется $O(n)$ сравнений (разбиение массива). Итак, для луучшего и среднего случая имеем:
$ T(n) = 2T(n/2) + O(n) -> O(n log n). $

Для худшего случая, то есть если опорный элемент постоянно оказывается минимальным или максимальным, например, при уже отсортированном массиве и выборе первого/последнего элемента в качестве `pivot`, рекурсия сводится к разбиению на подмассивы размером $n-1$ и $0$. Количество сравнений на каждом уровне — $O(n)$, а уровней — $n$. Итак, для худшего случая имеем:
$  T(n) = T(n-1) + O(n) -> O(n^2). $

== Сортировка слиянием (Merge Sort)

*Принцип работы:*
1. Массив рекурсивно делится пополам, пока не останутся подмассивы из одного элемента.
2. Подмассивы сливаются попарно, при этом элементы объединяются в отсортированном порядке.
3. В итоге получается отсортированный массив.

*Особенности:*
- Требует дополнительной памяти $O(n)$ для временного массива при слиянии.
- Стабильный алгоритм — сохраняет порядок равных элементов.
- Всегда работает за $O(n log n)$, независимо от исходного порядка.
- Хорошо подходит для сортировки больших данных и внешней сортировки.

*Реализация на C++:*
```cpp
void merge(std::vector<int>& arr, int left, int mid, int right) {
  int n1 = mid - left + 1;
  int n2 = right - mid;
  std::vector<int> L(n1), R(n2);
  for (int i = 0; i < n1; ++i) L[i] = arr[left + i];
  for (int j = 0; j < n2; ++j) R[j] = arr[mid + 1 + j];

  int i = 0, j = 0, k = left;
  while (i < n1 && j < n2) {
    if (L[i] <= R[j]) arr[k++] = L[i++];
    else arr[k++] = R[j++];
  }
  while (i < n1) arr[k++] = L[i++];
  while (j < n2) arr[k++] = R[j++];
}

void merge_sort(std::vector<int>& arr, int left, int right) {
  if (left < right) {
    int mid = left + (right - left) / 2;
    merge_sort(arr, left, mid);
    merge_sort(arr, mid + 1, right);
    merge(arr, left, mid, right);
  }
}
```

*Оценка сложности.* Найдём функцию трудоёмкости как у алгоритма «разделяй и властвуй». Массив рекурсивно делится пополам до подмассивов из одного элемента. Количество уровней рекурсии --- $log_2 n$. На каждом уровне происходит слияние, затрачивающее $O(n)$ времени. Значит, в любом случае имеем оценку:
$ T(n) = 2T(n/2) + O(n) -> O(n log n). $