== Z-функция

Вычисляем значения $z[i]$ по порядку, используя уже вычисленные значения для ускорения.

*Отрезок совпадения* — подстрока, совпадающая с префиксом строки $s$. Поддерживаем координаты $(l, r)$ самого правого найденного отрезка совпадения.

*Алгоритм*. Посимвольно проходимся по строке. Для текущего индекса $i$ есть два случая:

**Случай 1:** $i > r$ (позиция за пределами обработанного)
- Ищем $z[i]$ тривиально: проверяем $z[i] = 0, 1, 2, ...$
- Если $z[i] > 0$, обновляем $(l, r)$

**Случай 2:** $i ≤ r$ (позиция внутри отрезка совпадения)
- Используем симметрию: подстроки $s[l...r]$ и $s[0...r-l]$ совпадают
- Начальное приближение: $z[i] = min(r - i + 1, z[i - l])$
- Затем продолжаем тривиальным алгоритмом

*Формула инициализации:* $z[i] = min(r - i + 1, z[i - l])$

*Реализация*:
```cpp
vector<int> z_function (string s) {
	int n = (int) s.length();
	vector<int> z (n);
	for (int i=1, l=0, r=0; i<n; ++i) {
		if (i <= r)
			z[i] = min (r-i+1, z[i-l]);
		while (i+z[i] < n && s[z[i]] == s[i+z[i]])
			++z[i];
		if (i+z[i]-1 > r)
			l = i,  r = i+z[i]-1;
	}
	return z;
}
```

*Асимптотика*. каждая итерация внутреннего цикла `while` увеличивает правую границу $r$ на единицу.

- **При $i > r$:** цикл либо не выполняется, либо каждая итерация сдвигает $r$ вправо
- **При $i ≤ r$:** 
  - Если $z_0 < r - i + 1$: цикл не выполняется (значение уже точное)
  - Если $z_0 = r - i + 1$: каждая итерация увеличивает $r$
  - Случай $z_0 > r - i + 1$ невозможен по определению

Поскольку $r$ не может превышать $n-1$, общее число итераций не более $n$, следовательно сложность $O(n)$.

