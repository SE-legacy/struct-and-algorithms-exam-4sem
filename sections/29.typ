/ Динамическое программирование (ДП): --- метод решения задач через разбиение на перекрывающиеся подзадачи. Решения подзадач сохраняются и повторно используются, избегая избыточных вычислений.

Алгоритм Флойда-Уоршелла --- алгоритм нахождения длин кратчайших путей между всеми парами вершин во взвешенном ориентированном графе. Работает корректно, если в графе нет циклов отрицательной величины, а в случае, когда такой цикл есть, позволяет найти хотя бы один такой цикл.

Работает за $O(n^3)$ по времени и $O(n^2)$ по памяти. Это очевидно, так как у нас тройная вложенность циклов по `n`, а храним мы двумерный массив.

*Алгоритм:*
Обозначим длину кратчайшего пути между вершинами $u$ и $v$, содержащего, помимо $u$ и $v$, только вершины из множества ${1..i}$ как $d^((i))_(u v)$, $d^((0))_(u v)=ω_(u v)$

На каждом шаге алгоритма, мы будем брать очередную вершину $i$ и для всех пар вершин $u$ и $v$ вычислять $ d^((i))_(u v) = min(d^((i-1))_(u v), d^((i-1))_(u i), d^((i-1))_(i v)). $

То есть, если кратчайший путь из $u$ в $v$, содержащий только вершины из множества ${1..i}$, проходит через вершину $i$, то кратчайшим путем из $u$ в $v$ является кратчайший путь из $u$ в $i$, объединенный с кратчайшим путем из $i$ в $v$. В противном случае, когда этот путь не содержит вершины $i$, кратчайший путь из $u$ в $v$, содержащий только вершины из множества ${1..i}$ является кратчайшим путем из $u$ в $v$, содержащим только вершины из множества ${1..i-1}$.

*Псевдокод:*
```go
func floyd(w): 
    d = w
    for i in V
      for u in V
        for v in V
          d[u][v] = min(d[u][v], d[u][i] + d[i][v])
```

*Замечание:* При желании в функции можно завести дополнительный массив `next`, в котором после выполнения будет располагаться сам кратчайший путь.

#figure(image("../images/29-1.png"), caption: [*Пример работы алгоритма*], supplement: none)