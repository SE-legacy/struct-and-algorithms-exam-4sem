/ Пирамидальная сортировка (сортировка кучей): --- это алгоритм сортировки, основанный на структуре данных «куча» (heap), чаще всего --- двоичная куча.

В любом случае работает за $O(n log n)$ по времени и $O(1)$ по памяти.

*Алгоритм пирамидальной сортировки:*

- Строим из массива max-heap --- структуру, где корень содержит максимальный элемент.    

- Максимальный элемент (корень) меняется местами с последним элементом массива, уменьшается размер кучи на 1, и куча восстанавливается (перестраивается). 

- Процесс повторяется, пока весь массив не будет отсортирован.

*Пример:*
Пусть дан массив чисел ```cpp [3, 2, 4, 1, 5]```. Проведём полную трассировку:

#grid(columns: (1fr, 1fr), rows: (auto, auto, auto), stroke: black, gutter: .5em, inset: 1em)[
  0. Строим начальную кучу:
  ```
        5
       / \
     3    4
    /  \
   1    2
  ```
  Делаем построчный обход по куче, получаем массив: ```cpp [5, 3, 4, 1, 2]```
][
  1. Первый проход. Меняем первый и последний элементы в новом массиве: \ ```cpp [2, 3, 4, 1, 5]```. Так как корень был максимальным, то теперь он в конце (то есть на месте). Строим кучу для первых четырёх элементов:
  ```
       4
      / \
     3   2
    /
   1     
          (5) фиксировано
  ```
  Делаем построчный обход по куче, получаем массив: ```cpp [4, 3, 2, 1, 5]```
][
  2. Второй проход. Меняем первый и предпоследний элементы в новом массиве: ```cpp [1, 3, 2, 4, 5]```. Так как корень был максимальным, то теперь он на месте. Строим кучу для первых трёх элементов:
  ```
       3
      / \
     1   2
        (4, 5) фиксировано
  ```
    Делаем построчный обход по куче, получаем массив: ```cpp [3, 1, 2, 4, 5]```
][
  3. Третий проход. Меняем первый и третий элементы в новом массиве: ```cpp [2, 1, 3, 4, 5]```. Так как корень был максимальным, то теперь он на месте. Строим кучу для первых двух элементов:
  ```
       2
      /
     1  
        (3, 4, 5) фиксировано
  ```
    Делаем построчный обход по куче, получаем массив: ```cpp [2, 1, 3, 4, 5]```
][
  4. Четвёртый проход. Меняем первый и второй элементы в новом массиве: ```cpp [1, 2, 3, 4, 5]```.
][
  5. Массив отсортирован.
]

*Оценка сложности:*
1. *Построение кучи.* Построение `max-heap` из неотсортированного массива занимает время $O(n)$, а не $O(n log n)$, как может показаться на первый взгляд. Это связано с тем, что операция «просеивания» (`heapify`) выполняется не для всех элементов одинаково глубоко: для листьев — 0 операций, для элементов выше — меньше операций, чем для корня. \ Суммарно, учитывая глубину и количество узлов на каждом уровне, получается линейная сложность построения кучи.

2. *Извлечение максимума и восстановление кучи.* После построения кучи происходит $n$ итераций: на каждой извлекается максимальный элемент (корень) и перестраивается куча.\ Восстановление кучи (heapify) занимает время $O(log n)$, так как высота кучи --- логарифмическая по количеству элементов. Следовательно, весь этап извлечения максимума занимает $O(n log n)$.

Таким образом получаем оценку $O(n log n)$.

*Особенности использования.* На небольших массивах пирамидальная сортировка может уступать по скорости, например, сортировке Шелла или быстрой сортировке, из-за константных накладных расходов. Однако с ростом объема данных её стабильная асимптотика и отсутствие худших случаев делают её более предпочтительной.

С другой стороны, в отличие от некоторых алгоритмов, которые ускоряются на почти отсортированных данных, пирамидальная сортировка работает с одинаковой производительностью на любых данных, что обеспечивает предсказуемость при больших объемах. Однако это же и является проблемой, так как при почти отсортированном массиве сортировка не эффективна.

*Реализация на C++:*
```cpp
void heapify(std::vector<int>& arr, int n, int i) {
    for (int largest = i;;) {
        int left = 2 * largest + 1;
        int right = 2 * largest + 2;
        if (left < n && arr[left] > arr[largest]) largest = left;
        if (right < n && arr[right] > arr[largest]) largest = right;
        if (largest == i) break;
        std::swap(arr[i], arr[largest]);
        i = largest;
    }
}

void heapSort(std::vector<int>& arr) {
    int n = (int)arr.size();
    for (int i = n / 2 - 1; i >= 0; --i)
        heapify(arr, n, i);
    for (int i = n - 1; i > 0; --i) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

