/ Красно-черные деревья: --- это разновидность сбалансированных двоичных деревьев поиска, где каждый узел окрашен в красный или чёрный цвет. Они поддерживают балансировку дерева с помощью правил окраски и поворотов, что обеспечивает операции вставки, удаления и поиска за время $O(log n)$.

*Основные свойства:*
- Каждый узел либо красный, либо чёрный.
- Корень всегда чёрный.
- Все листья (```cpp nullptr```) считаются чёрными.
- Красный узел не может иметь красных детей (нет двух красных подряд).
- Для каждого узла все пути до листьев содержат одинаковое число чёрных узлов.

*Область применения:*  
Используются в стандартных библиотеках (std::map, std::set), СУБД, системах, где важна гарантированная производительность операций.

*Структура узла:*
```cpp
enum Color { RED, BLACK };

struct Node {
  int key;
  Color color;
  std::unique_ptr<Node> left;
  std::unique_ptr<Node> right;
  Node* parent;
  explicit Node(int k) : key(k), color(true), left(nullptr), right(nullptr), parent(nullptr) {}
};
```

== Повороты  
*Повороты* --- операции, меняющие структуру дерева локально, не нарушая порядка, и помогают восстановить баланс и свойства красно-чёрного дерева. Повороты используются при вставке и удалении для корректировки цветов и структуры.

- *Левый поворот:* делает правого ребёнка корнем поддерева, текущий узел становится левым ребёнком правого.

- *Правый поворот:* делает левого ребёнка корнем поддерева, текущий узел становится правым ребёнком левого.

#figure(image("../images/31-1.png"), caption: [*Левый поворот*], supplement: none) 

#figure(image("../images/31-2.png"), caption: [*Правый поворот*], supplement: none)

Отметим, что перекраска и повороты --- это *локальные* изменения и они не меняют сбалансированность на этажах выше.

== Балансировка

*Алгоритм балансировки:*

- Если правый ребёнок красный, а левый --- черный $=>$ левосторонний поворот.

- Если левый ребёнок и его левый ребёнок --- красные $=>$ правосторонний поворот.

- Если левый ребёнок и его правый ребёнок --- красные $=>$ правосторонний поворот.

== Вставка

При вставке нового узла он всегда окрашивается в красный, после чего может нарушиться балансировка (например, если его родитель тоже красный). Тогда применяются перекрашивания и повороты.

*Случай 1: Новый узел --- корень.* Если дерево пустое, новый узел становится корнем и перекрашивается в чёрный 

*Случай 2: Родитель чёрный.* Если родитель нового узла чёрный, баланс не нарушается, и ничего делать не нужно.

*Случай 3: Родитель и дядя красные.* Если так, то:
- Родитель и дядя перекрашиваются в чёрный.
- Дедушка --- в красный.
- Рекурсивно проверяем дедушку.

*Случай 4: Родитель красный, дядя чёрный (левый-правый или правый-левый случай).* Если новый узел --- правый потомок левого ребёнка (или наоборот), делаем поворот вокруг родителя, чтобы привести к случаю 5.

*Случай 5: Родитель красный, дядя чёрный (левый-левый или правый-правый случай).* Делаем поворот вокруг дедушки и перекрашиваем:
- Родитель становится чёрным.
- Дедушка --- красным.

Так как перекраска и повороты выполняются за константное время, а рекурсивные переходы по дедушке даже меньше $log n$ раз, то общая сложность вставки $O(log n)$.

== Удаление

При удалении узла из красно-чёрного дерева возможны несколько случаев, в зависимости от цвета узла и его потомков. Основная сложность возникает при удалении чёрного узла, так как это может нарушить баланс чёрных высот. Рассмотрим 6 основных случаев.

*Случай 1: Удаляемый узел --- корень без детей.* Если дерево состоит только из корня, просто удаляем его, и дерево становится пустым.

*Случай 2: У удаляемого узла есть красный потомок.* Заменяем удаляемый узел на его красного потомка и перекрашиваем его в чёрный.

*Случай 3: Удаляемый узел и его потомок --- чёрные, а брат чёрный, но у брата есть красный ребёнок.* Делаем поворот вокруг брата и перекрашиваем узлы, чтобы восстановить баланс.

*Случай 4: Удаляемый узел и его потомок --- чёрные, а брат красный.* Поворачиваем дерево вокруг родителя, делаем брата чёрным, а родителя --- красным, затем применяем другие случаи.

*Случай 5: Удаляемый узел, его потомок и брат --- чёрные, а родитель красный.* Перекрашиваем брата в красный, а родителя --- в чёрный.

*Случай 6: Все узлы (удаляемый, потомок, брат, родитель) --- чёрные.* Перекрашиваем брата в красный и рекурсивно проверяем родителя.

Все случаи обрабатываются за время $O(log n)$, так как дерево остаётся сбалансированным.