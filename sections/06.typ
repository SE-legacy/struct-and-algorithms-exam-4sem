#import "../conf.typ": definition, theorem, lets
== Алгоритмически неразрешимые задачи

Для алгоритмически невычислимых функций не существует алгоритма решения. Это означает невозможность решения всех задач одного класса одним и тем же приёмом, при этом *конкретные* задачи могут быть решаемыми.

== Примеры алгоритмически неразрешимых задач

*Пример*. $h(n)$ возвращает 0 или 1 -- найдутся ли в числе $pi$ $n$ идущих подряд девяток. Функция алгоритмически неразрешима, так как число $pi$ иррационально и по природе числа неизвестно, существует ли решение для всех $n$.

*Пример*. Функция $S(n)$, находящая сумму делителей для $n$-го совершенного числа. Нет способов проверить существование $n$-го числа и нет способов найти его кроме как перебрать все числа после $n-1$-го числа до первого подходящего, которое находится в непредсказуемой позиции.

== Методы доказательства алгоритмической неразрешимости

- *Прямой метод* использует диагональный метод Кантора. Заключается он в следующем: из предполоожения о разрешимости данной проблемы в ходе рассуждений приходят к противоречию.

- *Косвенный метод* состоит в следующем: показывается, что разрешимость исследуемой проблемы влечёт разрешимость проблемы, о которой уже известно, что она неразрешима. Метод сведения часто бывает более удобным, чем прямой метод. Применяя метод сведения, обычно ссылаются на искусственные задачи, которые не представляют самостоятельного интереса, но для которых легко непосредственно доказать их неразрешимость


#theorem(name: [Теорема Кантора о несчётности множества действительных чисел])[$NN$ и $[0, 1] subset RR$ имеют разную мощность.][]

Доказательство теоремы Кантора и состоит в диагональном методе.

== Проблема останова МТ в самоприменимости (доказательство неразрешимости)

#definition[*Самоприменимость* --- частный случай проблемы остановки. Означает свойство алгоритма успешно завершаться на данных, представляющих собой формальную запись этого же алгоритма]

*Пример*. Тождественнные преобразования строк в алфавите $A$ --- самоприменимый алгоритм.

#theorem(name: "Теорема о проблеме останова МТ")[$exists.not$ алгоритма, способного по описанию произвольного алгоритма и входных данных, определить, остановится ли алгоритм на этих данных][
1. Рассмотрим отображение $NN -> NN^*$, где:
- $NN^* = NN union "undef"$, $"undef"$ --- случай, когда алгоритм зацикливается.

Рассмотрим множество всех алгоритмов такого вида. Отметим, слова любого конечного алфавита можно однозначно закодировать натуральными числами.

#v(9pt)

2. #lets $exists$ $F(a, x)$, где $a$ --- номер описания алгоритма на некотором языке, $x$ --- входные данные. $F(a, x)$ --- результат выполнения алгоритма $a$ на $x$.

$F(a, x)$ перечисляет все вычислимые функции одного аргумента.

#v(9pt)

3. Рассмотрим её  с точки зреия самоприменимости, то есть случай $F(a, a)$, и построим $h(a) = F(a, a) + 1$. Вычислимость $h(a)$ очевидна.

#lets $x$ --- номер функции $h(a)$. Тогда $F(x, a) = h(a) - F(a, a) + 1 => F(x, a) = F(a, a) => x = a$.

$F(a, a) = h(a)$, $h(a) = F(a, a) + 1$ => противоречие $=>$ $F$ невычислима.
]
