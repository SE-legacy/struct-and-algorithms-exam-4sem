/ АВЛ–дерево: --- строго сбалансированное бинарное дерево поиска, где для каждой вершины высота её поддеревьев отличается не более чем на 1.

*Структура узла:*
```cpp
struct AVLNode {
    int key;
    int height;
    std::unique_ptr<AVLNode> left;
    std::unique_ptr<AVLNode> right;

    AVLNode(int k) : key(k), height(1), left(nullptr), right(nullptr) {}
};
``` 

== Повороты
Основные операции для поддержания баланса --- *повороты*:
1. *Правый поворот (LL-поворот)* --- применяется, когда левое поддерево слишком высокое. Алгоритм:
  - Берем левого ребенка (`x`) текущего узла (`y`)
  - Перемещаем правое поддерево `x` к левому поддереву `y`
  - Делаем `y` правым ребенком `x`
  - Обновляем высоты узлов

2. *Левый поворот (RR-поворот)* --- применяется, когда правое поддерево слишком высокое. Алгоритм:
  - Берем правого ребенка (`y`) текущего узла (`x`)
  - Перемещаем левое поддерево `y` к правому поддереву `x`
  - Делаем `x` левым ребенком `y`
  - Обновляем высоты узлов

3. *Лево-правый поворот (LR-поворот)* --- комбинация левого и правого поворотов. Алгоритм:
  - Сначала выполняем левый поворот для левого ребенка
  - Затем выполняем правый поворот для текущего узла

4. *Право-левый поворот (RL-поворот)* --- комбинация правого и левого поворотов. Алгоритм:
  - Сначала выполняем правый поворот для правого ребенка
  - Затем выполняем левый поворот для текущего узла


== Вставка

Вставка выполняется как в обычном бинарном дереве поиска, после чего проверяется баланс и при необходимости выполняются повороты.

*Случай 1: Баланс не нарушен (разница высот ≤ 1).* Ничего не делаем, дерево остаётся сбалансированным.

*Случай 2: Нарушен баланс влево-влево (LL-случай).* Выполняем *правый поворот* вокруг корня поддерева.

*Случай 3: Нарушен баланс вправо-вправо (RR-случай).* Выполняем *левый поворот* вокруг корня поддерева.

*Случай 4: Нарушен баланс влево-вправо (LR-случай).* Сначала выполняем *левый поворот* вокруг левого поддерева, затем *правый поворот* вокруг корня.

*Случай 5: Нарушен баланс вправо-влево (RL-случай).* Сначала выполняем *правый поворот* вокруг правого поддерева, затем *левый поворот* вокруг корня.

Общая сложность вставки: $O(log n)$, так как:
1. Поиск места для вставки --- $O(log n)$.
2. Проверка баланса и повороты --- $O(1)$ на каждом уровне (максимум $log n$ уровней).

== Удаление

Удаление выполняется как в бинарном дереве поиска, после чего проверяется баланс и при необходимости выполняются повороты.

*Случай 1: Удаляемый узел --- лист.* Просто удаляем узел и проверяем баланс родителей.

*Случай 2: У удаляемого узла есть только левый или только правый потомок.* Заменяем узел на его потомка и проверяем баланс.

*Случай 3: У удаляемого узла есть оба потомка.* Находим минимальный узел в правом поддереве (или максимальный в левом), заменяем удаляемый узел на него и рекурсивно удаляем заменяющий узел.

После удаления проверяем баланс и выполняем повороты (аналогично вставке):
1. *LL- или RR-несбалансированность* --- один поворот ($O(1)$).
2. *LR- или RL-несбалансированность* --- двойной поворот ($O(1)$).

Общая сложность удаления: $O(log n)$, так как:
1. Поиск и удаление узла --- $O(log n)$.
2. Проверка баланса и повороты --- $O(log n)$ (рекурсивно поднимаемся к корню).
