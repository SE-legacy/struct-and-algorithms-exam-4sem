/ Дерево рекурсии: --- граф, где:

- Корень --- начальный вызов функции.

- Узлы --- рекурсивные вызовы с параметрами.

- Листья --- базовые случаи (остановка рекурсии). 

- Глубина рекурсии $H_R(N)$ --- максимальное количество вложенных вызовов.

- Объем рекурсии $R(N)$ --- общее число узлов в дереве.

- Листья рекурсии $R_L (N)$ --- узлы без потомков (базовые случаи).

- Внутренние вершины $R_V (N)$ --- узлы с рекурсивными вызовами.

*Соотношение:* $R(N)=R_V (N)+R_L (N)$ 

== Оценка трудоёмкости $F_A (N)$

Общая трудоемкость складывается из:
1. Затраты на вызовы и возвраты $F_(с slash b)$. Формула
    $ F_R (N) = R(N)F_(с slash b), $
    где $ F_(с slash b)=2(p+r+k+l+1), $
    где $p$ --- параметры, $r$ – регистры, $k$ – возвращаемые значения, $l$ – локальные переменные.

2. Продуктивные вычисления $F_C (N)$:
  - В листьях:
  $ F_(C L) (N) = F_(C L) (1) dot R_L (N) $ 
  
  - Во внутренних узлах:  $F_(C V) (N)$ (зависит от алгоритма). 

Получаем итоговую формулу:
$ F_A (N)=F_R (N)+F_C (N) $

== Память $V(N)$

Зависит от глубины рекурсии $H_R (N)$. Формула:

$ V(N) = u_beta H_R (N)(p+r+k+l+1), $

где $u_beta$ --- размер слова в байтах.