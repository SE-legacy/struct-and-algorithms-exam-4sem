#import "../conf.typ": definition

/ Двоичное дерево поиска: --- это структура данных в виде двоичного дерева, где каждый узел содержит ключ (значение), а также ссылки на левое и правое поддерево. Для любого узла выполняются условия:

- Все ключи в левом поддереве не больше ключа этого узла.
- Все ключи в правом поддереве больше ключа этого узла.

Это свойство позволяет эффективно выполнять операции поиска, вставки и удаления.

*Область применения:* реализация структур данных (map, hashmap, set, и т.п.), индексы СУБД.

*Структура узла:*
```cpp
struct Node {
  int key;
  std::unique_ptr<Node> left;
  std::unique_ptr<Node> right;
  explicit Node(int k) : key(k), left(nullptr), right(nullptr) {}
};
```
Аллокация памяти под структуру работает за $O(1)$

== Вставка
*Алгоритм вставки:*

1. Если дерево пустое, то создаём корень. Всё.
2. Если дерево не пустое, то:
  - Если узел не больше вставляемого, то идём в левое поддерево.
  - Если узел больше вставляемого, то идём в правое поддерево.
3. Если нашли пустое место ```cpp nullptr```, то вставляем. Иначе рекурсивно повторяем алгоритм

*Реализация на C++:*

```cpp
std::unique_ptr<Node> insert(std::unique_ptr<Node> node, int key) {
  if (!node) return std::make_unique<Node>(key);
  if (key <= node->key)
    node->left = insert(std::move(node->left), key);
  else
    node->right = insert(std::move(node->right), key);
  return node;
}
```

*Оценка сложности.* В лучшем случае (дерево сбалансировано) вставка пройдёт за $O(log n)$. Если же дерево вырожденное (походит на связный список), то вставка пройдёт за $O(n)$.

== Удаление

*Алгоритм удаления:*

1. Если дерево пустое (узел ```cpp nullptr```), возвращаем ```cpp nullptr```.
2. Ищем узел с ключом для удаления:
  - Если ключ не больше текущего узла --- идём в левое поддерево, иначе в правое.
3. Если нашли узел для удаления:
  - Если у узла нет детей --- просто удаляем (возвращаем ```cpp nullptr```).
  - Если есть один ребёнок --- заменяем узел на этого ребёнка.
  - Если есть два ребёнка --- выбираем один из них с помощью алгоритма разбиения дерева.

*Реализация на C++:*

```cpp
std::unique_ptr<Node> remove(std::unique_ptr<Node> node, int key) {
  if (!node) return nullptr;
  if (key < node->key)
    node->left = remove(std::move(node->left), key);
  else if (key > node->key)
    node->right = remove(std::move(node->right), key);
  else {
    if (!node->left && !node->right)
      return nullptr;
    else if (!node->left)
      return node->right;
    else if (!node->right)
      return node->left;
    else {
      auto min = std::minmax_element(node->left->key, node->right->key);
      node->key = *min.first;
      node->left = remove(std::move(node->left), *min.first);
    }
  }
  return node;
}
```

*Оценка сложности.* Удаление пройдёт за $O(log n)$. Если дерево вырожденное (походит на связный список), то удаление пройдёт за $O(n)$.

== Поиск

*Алгоритм поиска:*

1. Если узел пустой (```cpp nullptr```) или ключ совпадает с ключом узла — возвращаем узел (или ```cpp nullptr``` при отсутствии).

2. Если искомый ключ меньше ключа узла --- идём в левое поддерево, иначе --- в правое.

3. Повторяем рекурсивно, пока не найдём нужный узел или не дойдём до ```cpp nullptr```.

*Реализация на C++:*

```cpp
Node* search(const std::unique_ptr<Node>& node, int key) {
  if (!node || node->key == key) return node.get();
  if (key < node->key) return search(node->left, key);
  else return search(node->right, key);
}
```

*Оценка сложности.* Лучший случай — $O(log n)$, худший — $O(n)$, аналогично вставке и удалению.

== Обходы дерева

- *Inorder* (симметричный): левое поддерево, текущий узел, правое поддерево. Выдаёт элементы в отсортированном порядке для BST.

- *Preorder* (прямой): текущий узел, левое поддерево, правое поддерево. Используется для копирования дерева, сериализации.

- *Postorder* (обратный): левое поддерево, правое поддерево, текущий узел. Используется для удаления дерева, вычисления выражений.
