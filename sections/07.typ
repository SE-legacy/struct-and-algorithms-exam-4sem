#import "../conf.typ": definition

== Трудоёмкость алгоритма и её функция

#definition[*Трудоёмкость алгоритма* --- количество элементарных операци, совершаемых алгоритмом для решения конкретной проблемы, заданной $N + M + S_d + S_r$ словами в памяти, где
- $N$ --- количество слов для описания проблемы
- $M$ --- программа-решение из $M$ машинных инструкций
- $S_d$ --- память для хранения промежуточных результатов
- $S_r$ --- память для организации вычислительного процесса
]

#definition[*Функция трудоёмкости $T_a (N)$* --- отношение, связывающее входные данные алгоритма с количеством элементарных операций.]

Комплексный анализ алгоритма может быть выполнен на основе комплексной оценки ресурсов формальной системы, требуемых алгоритмом для решения конкретных проблем. Очевидно, что для различных областей применения веса ресурсов будут различны, что приводит к следующей комплексной оценке алгоритма:

#definition[*Комплесная оценка алгоритма* ($c_i$ --- веса ресурсов):
$ psi_A = c_1 * T_a (N) + c_2 dot N + c_3 * M + c_4 * S_d + c_5 S_d $
]
== Классификация алгоритмов по виду функции трудоёмкости

=== Количественно-зависимые

Алгоритмы, $T_a$ которых зависит только от размерности входа:

$T_a (D) = T_a (|D|) = T_a (N)$

*Пример*: умножение матриц

=== Параметрически-зависимые

$T_a$ зависит от конкретных значений обрабатываемых слов:

$T_a (D) = T_a (d_1, dots, d_n) = T_a (P_1, dots, P_m), space m <= n$

*Пример*: рекурсивное вычисление $x^k$

== Количественно-параметрические

Комбинация первых двух вариантов:

$T_a (D) = T_a (N, d_1, dots, d_n) = T_a (N, P_1, dots, P_m), space m <= n$

== Порядко-зависимые

Количество операций зависит от порядка расположения исходных объектов.

$T_a (D_p_i) != T_a (D_p_j)$

*Пример*: алгоритмы поиска минимума и максимума в массиве
